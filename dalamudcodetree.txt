// ReSharper restore InconsistentNaming
﻿using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using Newtonsoft.Json;
using Serilog;
using XIVLauncher.Common.PlatformAbstractions;

namespace LibDalamud.Common.Dalamud
{
    
    public class DalamudLauncher
    {
        private readonly DalamudLoadMethod loadMethod;
        private readonly DirectoryInfo gamePath;
        private readonly DirectoryInfo configDirectory;
        private readonly ClientLanguage language;
        private readonly IDalamudRunner runner;
        private readonly DalamudUpdater updater;
        private readonly int injectionDelay;
        private readonly bool fakeLogin;
        private readonly bool noPlugin;
        private readonly bool noThirdPlugin;
        private readonly string troubleshootingData;

        public enum DalamudInstallState
        {
            Ok,
            Failed,
            OutOfDate,
        }

        public DalamudLauncher(IDalamudRunner runner, DalamudUpdater updater, DalamudLoadMethod loadMethod, DirectoryInfo gamePath, DirectoryInfo configDirectory, ClientLanguage clientLanguage, int injectionDelay, bool fakeLogin, bool noPlugin, bool noThirdPlugin, string troubleshootingData)
        {
            this.runner = runner;
            this.updater = updater;
            this.loadMethod = loadMethod;
            this.gamePath = gamePath;
            this.configDirectory = configDirectory;
            this.language = clientLanguage;
            this.injectionDelay = injectionDelay;
            this.fakeLogin = fakeLogin;
            this.noPlugin = noPlugin;
            this.noThirdPlugin = noThirdPlugin;
            this.troubleshootingData = troubleshootingData;
        }

        public const string REMOTE_BASE = "https://kamori.goats.dev/Dalamud/Release/VersionInfo?track=";

        public DalamudInstallState HoldForUpdate(DirectoryInfo gamePath)
        {
            Log.Information("[HOOKS] DalamudLauncher::HoldForUpdate(gp:{0})", gamePath.FullName);

            if (this.updater.State != DalamudUpdater.DownloadState.Done)
                this.updater.ShowOverlay();

            while (this.updater.State != DalamudUpdater.DownloadState.Done)
            {
                if (this.updater.State == DalamudUpdater.DownloadState.Failed)
                {
                    this.updater.CloseOverlay();
                    return DalamudInstallState.Failed;
                }

                if (this.updater.State == DalamudUpdater.DownloadState.NoIntegrity)
                {
                    this.updater.CloseOverlay();
                    throw new DalamudRunnerException("No runner integrity");
                }

                Thread.Yield();
            }

            if (!this.updater.Runner.Exists)
                throw new DalamudRunnerException("Runner not present");

            if (!ReCheckVersion(gamePath))
            {
                this.updater.SetOverlayProgress(IDalamudLoadingOverlay.DalamudUpdateStep.Unavailable);
                this.updater.ShowOverlay();
                Log.Error("[HOOKS] ReCheckVersion fail");

                return DalamudInstallState.OutOfDate;
            }

            return DalamudInstallState.Ok;
        }

        public Process Run(FileInfo gameExe, string gameArgs, IDictionary<string, string> environment)
        {
            Log.Information("[HOOKS] DalamudLauncher::Run(gp:{0}, cl:{1})", this.gamePath.FullName, this.language);

            var ingamePluginPath = Path.Combine(this.configDirectory.FullName, "installedPlugins");
            var defaultPluginPath = Path.Combine(this.configDirectory.FullName, "devPlugins");

            Directory.CreateDirectory(ingamePluginPath);
            Directory.CreateDirectory(defaultPluginPath);

            var startInfo = new DalamudStartInfo
            {
                Language = language,
                PluginDirectory = ingamePluginPath,
                DefaultPluginDirectory = defaultPluginPath,
                ConfigurationPath = DalamudSettings.GetConfigPath(this.configDirectory),
                AssetDirectory = this.updater.AssetDirectory.FullName,
                GameVersion = Repository.Ffxiv.GetVer(gamePath),
                WorkingDirectory = this.updater.Runner.Directory?.FullName,
                DelayInitializeMs = this.injectionDelay,
                TroubleshootingPackData = this.troubleshootingData,
            };

            if (this.loadMethod != DalamudLoadMethod.ACLonly)
                Log.Information("[HOOKS] DelayInitializeMs: {0}", startInfo.DelayInitializeMs);

            switch (this.loadMethod)
            {
                case DalamudLoadMethod.EntryPoint:
                    Log.Verbose("[HOOKS] Now running OEP rewrite");
                    break;

                case DalamudLoadMethod.DllInject:
                    Log.Verbose("[HOOKS] Now running DLL inject");
                    break;

                case DalamudLoadMethod.ACLonly:
                    Log.Verbose("[HOOKS] Now running ACL-only fix without injection");
                    break;
            }

            var process = this.runner.Run(this.updater.Runner, this.fakeLogin, this.noPlugin, this.noThirdPlugin, gameExe, gameArgs, environment, this.loadMethod, startInfo);

            this.updater.CloseOverlay();

            if (this.loadMethod != DalamudLoadMethod.ACLonly)
                Log.Information("[HOOKS] Started dalamud!");

            return process;
        }

        private bool ReCheckVersion(DirectoryInfo gamePath)
        {
            if (this.updater.State != DalamudUpdater.DownloadState.Done)
                return false;

            if (this.updater.RunnerOverride != null)
                return true;

            var info = DalamudVersionInfo.Load(new FileInfo(Path.Combine(this.updater.Runner.DirectoryName!,
                "version.json")));

            if (Repository.Ffxiv.GetVer(gamePath) != info.SupportedGameVer)
                return false;

            return true;
        }

        public static bool CanRunDalamud(DirectoryInfo gamePath)
        {
            using var client = new WebClient();

            var versionInfoJson = client.DownloadString(REMOTE_BASE + "release");
            var remoteVersionInfo = JsonConvert.DeserializeObject<DalamudVersionInfo>(versionInfoJson);

            if (Repository.Ffxiv.GetVer(gamePath) != remoteVersionInfo.SupportedGameVer)
                return false;

            return true;
        }
    }
}﻿namespace LibDalamud.Common.Dalamud
{
    public enum DalamudLoadMethod
    {
        [SettingsDescription("Entrypoint", "dummy")]
        EntryPoint,

        [SettingsDescription("DLL Injection", "dummy")]
        DllInject,

        [SettingsDescription("ACL-only fix", "dummy")]
        ACLonly,
    };
}using System;

namespace LibDalamud.Common.Dalamud;

public class DalamudRunnerException : Exception
{
     public DalamudRunnerException(string message, Exception innerException = null)
          : base(message, innerException)
     {
     }
}   using System;
using System.IO;
using Newtonsoft.Json;
using Serilog;

namespace LibDalamud.Common.Dalamud
{
    public class DalamudSettings
    {
        public string? DalamudBetaKey { get; set; } = null;
        public bool DoDalamudRuntime { get; set; } = false;
        public string DalamudBetaKind { get; set; }

        public static string GetConfigPath(DirectoryInfo configFolder) => Path.Combine(configFolder.FullName, "dalamudConfig.json");

        public static DalamudSettings GetSettings(DirectoryInfo configFolder)
        {
            var configPath = GetConfigPath(configFolder);
            DalamudSettings deserialized = null;

            try
            {
                deserialized = File.Exists(configPath) ? JsonConvert.DeserializeObject<DalamudSettings>(File.ReadAllText(configPath)) : new DalamudSettings();
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Couldn't deserialize Dalamud settings");
            }

            deserialized ??= new DalamudSettings(); // In case the .json is corrupted
            return deserialized;
        }
    }
}﻿using System;

namespace LibDalamud.Common.Dalamud
{
    [Serializable]
    public sealed class DalamudStartInfo
    {
        public string WorkingDirectory;
        public string ConfigurationPath;

        public string PluginDirectory;
        public string DefaultPluginDirectory;
        public string AssetDirectory;
        public ClientLanguage Language;
        public int DelayInitializeMs;

        public string GameVersion;
        public string TroubleshootingPackData;
    }
}using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Threading.Tasks;
using LibDalamud.Common.Util;
using Newtonsoft.Json;
using Serilog;
using XIVLauncher.Common.PlatformAbstractions;
using XIVLauncher.Common.Util;

namespace LibDalamud.Common.Dalamud
{
    public class DalamudUpdater
    {
        private readonly DirectoryInfo addonDirectory;
        private readonly DirectoryInfo runtimeDirectory;
        private readonly DirectoryInfo assetDirectory;
        private readonly DirectoryInfo configDirectory;
        private readonly IUniqueIdCache? cache;

        private readonly TimeSpan defaultTimeout = TimeSpan.FromMinutes(15);

        private bool forceProxy = false;

        public DownloadState State { get; private set; } = DownloadState.Unknown;
        public bool IsStaging { get; private set; } = false;

        private FileInfo runnerInternal;

        public FileInfo Runner
        {
            get
            {
                if (RunnerOverride != null)
                    return RunnerOverride;

                return runnerInternal;
            }
            private set => runnerInternal = value;
        }

        public DirectoryInfo Runtime => this.runtimeDirectory;

        public FileInfo RunnerOverride { get; set; }

        public DirectoryInfo AssetDirectory { get; private set; }

        public IDalamudLoadingOverlay Overlay { get; set; }

        public string RolloutBucket { get; set; }

        public enum DownloadState
        {
            Unknown,
            Done,
            Failed,
            NoIntegrity
        }

        public DalamudUpdater(DirectoryInfo addonDirectory, DirectoryInfo runtimeDirectory, DirectoryInfo assetDirectory, DirectoryInfo configDirectory, IUniqueIdCache? cache, string? dalamudRolloutBucket)
        {
            this.addonDirectory = addonDirectory;
            this.runtimeDirectory = runtimeDirectory;
            this.assetDirectory = assetDirectory;
            this.configDirectory = configDirectory;
            this.cache = cache;

            this.RolloutBucket = dalamudRolloutBucket;

            if (this.RolloutBucket == null)
            {
                var rng = new Random();
                this.RolloutBucket = rng.Next(0, 9) >= 7 ? "Canary" : "Control";
            }
        }

        public void SetOverlayProgress(IDalamudLoadingOverlay.DalamudUpdateStep progress)
        {
            Overlay.SetStep(progress);
        }

        public void ShowOverlay()
        {
            Overlay.SetVisible();
        }

        public void CloseOverlay()
        {
            Overlay.SetInvisible();
        }

        private void ReportOverlayProgress(long? size, long downloaded, double? progress)
        {
            Overlay.ReportProgress(size, downloaded, progress);
        }

        public void Run()
        {
            Log.Information("[DUPDATE] Starting...");

            Task.Run(async () =>
            {
                const int MAX_TRIES = 10;

                for (var tries = 0; tries < MAX_TRIES; tries++)
                {
                    try
                    {
                        await UpdateDalamud().ConfigureAwait(true);
                        break;
                    }
                    catch (Exception ex)
                    {
                        Log.Error(ex, "[DUPDATE] Update failed, try {TryCnt}/{MaxTries}...", tries, MAX_TRIES);
                        this.forceProxy = true;
                    }
                }

                if (this.State != DownloadState.Done) this.State = DownloadState.Failed;
            });
        }

        private static string GetBetaTrackName(DalamudSettings settings) =>
            string.IsNullOrEmpty(settings.DalamudBetaKind) ? "staging" : settings.DalamudBetaKind;

        private async Task<(DalamudVersionInfo release, DalamudVersionInfo? staging)> GetVersionInfo(DalamudSettings settings)
        {
            using var client = new HttpClient
            {
                Timeout = this.defaultTimeout,
            };

            client.DefaultRequestHeaders.CacheControl = new CacheControlHeaderValue
            {
                NoCache = true,
            };

            var versionInfoJsonRelease = await client.GetStringAsync(DalamudLauncher.REMOTE_BASE + $"release&bucket={this.RolloutBucket}").ConfigureAwait(false);

            DalamudVersionInfo versionInfoRelease = JsonConvert.DeserializeObject<DalamudVersionInfo>(versionInfoJsonRelease);

            DalamudVersionInfo? versionInfoStaging = null;

            if (!string.IsNullOrEmpty(settings.DalamudBetaKey))
            {
                var versionInfoJsonStaging = await client.GetAsync(DalamudLauncher.REMOTE_BASE + GetBetaTrackName(settings)).ConfigureAwait(false);

                if (versionInfoJsonStaging.StatusCode != HttpStatusCode.BadRequest)
                    versionInfoStaging = JsonConvert.DeserializeObject<DalamudVersionInfo>(await versionInfoJsonStaging.Content.ReadAsStringAsync().ConfigureAwait(false));
            }

            return (versionInfoRelease, versionInfoStaging);
        }

        private async Task UpdateDalamud()
        {
            var settings = DalamudSettings.GetSettings(this.configDirectory);

            // GitHub requires TLS 1.2, we need to hardcode this for Windows 7
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

            var (versionInfoRelease, versionInfoStaging) = await GetVersionInfo(settings).ConfigureAwait(false);

            var remoteVersionInfo = versionInfoRelease;

            if (versionInfoStaging?.Key != null && versionInfoStaging.Key == settings.DalamudBetaKey)
            {
                remoteVersionInfo = versionInfoStaging;
                IsStaging = true;
                Log.Information("[DUPDATE] Using staging version {Kind} with key {Key} ({Hash})", settings.DalamudBetaKind, settings.DalamudBetaKey, remoteVersionInfo.AssemblyVersion);
            }
            else
            {
                Log.Information("[DUPDATE] Using release version ({Hash})", remoteVersionInfo.AssemblyVersion);
            }

            var versionInfoJson = JsonConvert.SerializeObject(remoteVersionInfo);

            var addonPath = new DirectoryInfo(Path.Combine(this.addonDirectory.FullName, "Hooks"));
            var currentVersionPath = new DirectoryInfo(Path.Combine(addonPath.FullName, remoteVersionInfo.AssemblyVersion));
            var runtimePaths = new DirectoryInfo[]
            {
                new(Path.Combine(this.runtimeDirectory.FullName, "host", "fxr", remoteVersionInfo.RuntimeVersion)),
                new(Path.Combine(this.runtimeDirectory.FullName, "shared", "Microsoft.NETCore.App", remoteVersionInfo.RuntimeVersion)),
                new(Path.Combine(this.runtimeDirectory.FullName, "shared", "Microsoft.WindowsDesktop.App", remoteVersionInfo.RuntimeVersion)),
            };

            if (!currentVersionPath.Exists || !IsIntegrity(currentVersionPath))
            {
                Log.Information("[DUPDATE] Not found, redownloading");

                SetOverlayProgress(IDalamudLoadingOverlay.DalamudUpdateStep.Dalamud);

                try
                {
                    await DownloadDalamud(currentVersionPath, remoteVersionInfo).ConfigureAwait(true);
                    CleanUpOld(addonPath, remoteVersionInfo.AssemblyVersion);

                    // This is a good indicator that we should clear the UID cache
                    cache?.Reset();
                }
                catch (Exception ex)
                {
                    Log.Error(ex, "[DUPDATE] Could not download dalamud");

                    State = DownloadState.NoIntegrity;
                    return;
                }
            }

            if (remoteVersionInfo.RuntimeRequired || settings.DoDalamudRuntime)
            {
                Log.Information("[DUPDATE] Now starting for .NET Runtime {0}", remoteVersionInfo.RuntimeVersion);

                var versionFile = new FileInfo(Path.Combine(this.runtimeDirectory.FullName, "version"));
                var localVersion = "5.0.6"; // This is the version we first shipped. We didn't write out a version file, so we can't check it.
                if (versionFile.Exists)
                    localVersion = File.ReadAllText(versionFile.FullName);

                if (!this.runtimeDirectory.Exists)
                    Directory.CreateDirectory(this.runtimeDirectory.FullName);

                var integrity = await CheckRuntimeHashes(runtimeDirectory, localVersion).ConfigureAwait(false);

                if (runtimePaths.Any(p => !p.Exists) || localVersion != remoteVersionInfo.RuntimeVersion || !integrity)
                {
                    Log.Information("[DUPDATE] Not found, outdated or no integrity: {LocalVer} - {RemoteVer}", localVersion, remoteVersionInfo.RuntimeVersion);

                    SetOverlayProgress(IDalamudLoadingOverlay.DalamudUpdateStep.Runtime);

                    try
                    {
                        await DownloadRuntime(this.runtimeDirectory, remoteVersionInfo.RuntimeVersion).ConfigureAwait(false);
                        File.WriteAllText(versionFile.FullName, remoteVersionInfo.RuntimeVersion);
                    }
                    catch (Exception ex)
                    {
                        Log.Error(ex, "[DUPDATE] Could not download runtime");

                        State = DownloadState.Failed;
                        return;
                    }
                }
            }

            try
            {
                this.SetOverlayProgress(IDalamudLoadingOverlay.DalamudUpdateStep.Assets);
                this.ReportOverlayProgress(null, 0, null);
                AssetDirectory = await AssetManager.EnsureAssets(this.assetDirectory, this.forceProxy).ConfigureAwait(true);
            }
            catch (Exception ex)
            {
                Log.Error(ex, "[DUPDATE] Asset ensurement error, bailing out...");
                State = DownloadState.Failed;
                return;
            }

            if (!IsIntegrity(currentVersionPath))
            {
                Log.Error("[DUPDATE] Integrity check failed after ensurement.");

                State = DownloadState.NoIntegrity;
                return;
            }

            WriteVersionJson(currentVersionPath, versionInfoJson);

            Log.Information("[DUPDATE] All set for " + remoteVersionInfo.SupportedGameVer);

            Runner = new FileInfo(Path.Combine(currentVersionPath.FullName, "Dalamud.Injector.exe"));

            State = DownloadState.Done;
            SetOverlayProgress(IDalamudLoadingOverlay.DalamudUpdateStep.Starting);
        }

        private static bool CanRead(FileInfo info)
        {
            try
            {
                using var stream = info.OpenRead();
                stream.ReadByte();
            }
            catch
            {
                return false;
            }

            return true;
        }

        public static bool IsIntegrity(DirectoryInfo addonPath)
        {
            var files = addonPath.GetFiles();

            try
            {
                if (!CanRead(files.First(x => x.Name == "Dalamud.Injector.exe"))
                    || !CanRead(files.First(x => x.Name == "Dalamud.dll"))
                    || !CanRead(files.First(x => x.Name == "ImGuiScene.dll")))
                {
                    Log.Error("[DUPDATE] Can't open files for read");
                    return false;
                }

                var hashesPath = Path.Combine(addonPath.FullName, "hashes.json");

                if (!File.Exists(hashesPath))
                {
                    Log.Error("[DUPDATE] No hashes.json");
                    return false;
                }

                return CheckIntegrity(addonPath, File.ReadAllText(hashesPath));
            }
            catch (Exception ex)
            {
                Log.Error(ex, "[DUPDATE] No dalamud integrity");
                return false;
            }
        }

        private static bool CheckIntegrity(DirectoryInfo directory, string hashesJson)
        {
            try
            {
                Log.Verbose("[DUPDATE] Checking integrity of {Directory}", directory.FullName);

                var hashes = JsonConvert.DeserializeObject<Dictionary<string, string>>(hashesJson);

                foreach (var hash in hashes)
                {
                    var file = Path.Combine(directory.FullName, hash.Key.Replace("\\", "/"));
                    using var fileStream = File.OpenRead(file);
                    using var md5 = MD5.Create();

                    var hashed = BitConverter.ToString(md5.ComputeHash(fileStream)).ToUpperInvariant().Replace("-", string.Empty);

                    if (hashed != hash.Value)
                    {
                        Log.Error("[DUPDATE] Integrity check failed for {0} ({1} - {2})", file, hash.Value, hashed);
                        return false;
                    }

                    Log.Verbose("[DUPDATE] Integrity check OK for {0} ({1})", file, hashed);
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, "[DUPDATE] Integrity check failed");
                return false;
            }

            return true;
        }

        private static void CleanUpOld(DirectoryInfo addonPath, string currentVer)
        {
            if (!addonPath.Exists)
                return;

            foreach (var directory in addonPath.GetDirectories())
            {
                if (directory.Name == "dev" || directory.Name == currentVer) continue;

                try
                {
                    directory.Delete(true);
                }
                catch
                {
                    // ignored
                }
            }
        }

        private static void WriteVersionJson(DirectoryInfo addonPath, string info)
        {
            File.WriteAllText(Path.Combine(addonPath.FullName, "version.json"), info);
        }

        private async Task DownloadDalamud(DirectoryInfo addonPath, DalamudVersionInfo version)
        {
            // Ensure directory exists
            if (!addonPath.Exists)
                addonPath.Create();
            else
            {
                addonPath.Delete(true);
                addonPath.Create();
            }

            var downloadPath = PlatformHelpers.GetTempFileName();

            if (File.Exists(downloadPath))
                File.Delete(downloadPath);

            await this.DownloadFile(version.DownloadUrl, downloadPath, this.defaultTimeout).ConfigureAwait(false);
            ZipFile.ExtractToDirectory(downloadPath, addonPath.FullName);

            File.Delete(downloadPath);

            try
            {
                var devPath = new DirectoryInfo(Path.Combine(addonPath.FullName, "..", "dev"));

                if (!devPath.Exists)
                    devPath.Create();
                else
                {
                    devPath.Delete(true);
                    devPath.Create();
                }

                foreach (var fileInfo in addonPath.GetFiles())
                {
                    fileInfo.CopyTo(Path.Combine(devPath.FullName, fileInfo.Name));
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, "[DUPDATE] Could not copy to dev folder.");
            }
        }

        private async Task<bool> CheckRuntimeHashes(DirectoryInfo runtimePath, string version)
        {
#if DEBUG
            Log.Warning("Debug build, ignoring runtime hash check");
            return true;
#endif

            var hashesFile = new FileInfo(Path.Combine(runtimePath.FullName, $"hashes-{version}.json"));
            string? runtimeHashes = null;

            if (!hashesFile.Exists)
            {
                Log.Verbose("Hashes file does not exist, redownloading...");

                using var client = new HttpClient();
                runtimeHashes = await client.GetStringAsync($"https://kamori.goats.dev/Dalamud/Release/Runtime/Hashes/{version}").ConfigureAwait(false);

                File.WriteAllText(hashesFile.FullName, runtimeHashes);
            }
            else
            {
                runtimeHashes = File.ReadAllText(hashesFile.FullName);
            }

            return CheckIntegrity(runtimePath, runtimeHashes);
        }

        private async Task DownloadRuntime(DirectoryInfo runtimePath, string version)
        {
            // Ensure directory exists
            if (!runtimePath.Exists)
            {
                runtimePath.Create();
            }
            else
            {
                runtimePath.Delete(true);
                runtimePath.Create();
            }

            var dotnetUrl = $"https://kamori.goats.dev/Dalamud/Release/Runtime/DotNet/{version}";
            var desktopUrl = $"https://kamori.goats.dev/Dalamud/Release/Runtime/WindowsDesktop/{version}";

            var downloadPath = PlatformHelpers.GetTempFileName();

            if (File.Exists(downloadPath))
                File.Delete(downloadPath);

            await this.DownloadFile(dotnetUrl, downloadPath, this.defaultTimeout).ConfigureAwait(false);
            ZipFile.ExtractToDirectory(downloadPath, runtimePath.FullName);

            await this.DownloadFile(desktopUrl, downloadPath, this.defaultTimeout).ConfigureAwait(false);
            ZipFile.ExtractToDirectory(downloadPath, runtimePath.FullName);

            File.Delete(downloadPath);
        }

        private async Task DownloadFile(string url, string path, TimeSpan timeout)
        {
            if (this.forceProxy && url.Contains("/File/Get/"))
            {
                url = url.Replace("/File/Get/", "/File/GetProxy/");
            }

            using var downloader = new HttpClientDownloadWithProgress(url, path);
            downloader.ProgressChanged += this.ReportOverlayProgress;

            await downloader.Download(timeout).ConfigureAwait(false);
        }
    }
}﻿using System.IO;
using Newtonsoft.Json;

namespace LibDalamud.Common.Dalamud
{
    internal class DalamudVersionInfo
    {
        public string AssemblyVersion { get; set; }
        public string SupportedGameVer { get; set; }
        public string RuntimeVersion { get; set; }
        public bool RuntimeRequired { get; set; }
        public string Key { get; set; }
        public string DownloadUrl { get; set; }

        public static DalamudVersionInfo Load(FileInfo file) =>
            JsonConvert.DeserializeObject<DalamudVersionInfo>(File.ReadAllText(file.FullName));
    }
}﻿using Microsoft.Win32;
using Microsoft.Win32.SafeHandles;
using Newtonsoft.Json;
using Steamworks;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Text;
using System.Threading.Tasks;
using XIVLauncher.Common.PlatformAbstractions;

namespace LibDalamud.Common.Dalamud
{
    public class WindowsDalamudRunner : IDalamudRunner
    {
        public Process? Run(FileInfo runner, bool fakeLogin, bool noPlugins, bool noThirdPlugins, FileInfo gameExe, string gameArgs, IDictionary<string, string> environment, DalamudLoadMethod loadMethod, DalamudStartInfo startInfo)
        {
            var inheritableCurrentProcess = GetInheritableCurrentProcessHandle();

            var launchArguments = new List<string>
        {
            "launch",
            $"--mode={(loadMethod == DalamudLoadMethod.EntryPoint ? "entrypoint" : "inject")}",
            $"--handle-owner={(long)inheritableCurrentProcess.Handle}",
            $"--game=\"{gameExe.FullName}\"",
            $"--dalamud-working-directory=\"{startInfo.WorkingDirectory}\"",
            $"--dalamud-configuration-path=\"{startInfo.ConfigurationPath}\"",
            $"--dalamud-plugin-directory=\"{startInfo.PluginDirectory}\"",
            $"--dalamud-dev-plugin-directory=\"{startInfo.DefaultPluginDirectory}\"",
            $"--dalamud-asset-directory=\"{startInfo.AssetDirectory}\"",
            $"--dalamud-client-language={(int)startInfo.Language}",
            $"--dalamud-delay-initialize={startInfo.DelayInitializeMs}",
            $"--dalamud-tspack-b64={Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(startInfo.TroubleshootingPackData))}",
        };

            if (loadMethod == DalamudLoadMethod.ACLonly)
                launchArguments.Add("--without-dalamud");

            if (fakeLogin)
                launchArguments.Add("--fake-arguments");

            if (noPlugins)
                launchArguments.Add("--no-plugin");

            if (noThirdPlugins)
                launchArguments.Add("--no-3rd-plugin");

            launchArguments.Add("--");
            launchArguments.Add(gameArgs);

            var psi = new ProcessStartInfo(runner.FullName)
            {
                Arguments = string.Join(" ", launchArguments),
                RedirectStandardOutput = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            foreach (var keyValuePair in environment)
            {
                if (psi.EnvironmentVariables.ContainsKey(keyValuePair.Key))
                    psi.EnvironmentVariables[keyValuePair.Key] = keyValuePair.Value;
                else
                    psi.EnvironmentVariables.Add(keyValuePair.Key, keyValuePair.Value);
            }

            try
            {
                var dalamudProcess = Process.Start(psi);
                var output = dalamudProcess.StandardOutput.ReadLine();

                if (output == null)
                    throw new DalamudRunnerException("An internal Dalamud error has occured");

                try
                {
                    var dalamudConsoleOutput = JsonConvert.DeserializeObject<DalamudConsoleOutput>(output);
                    Process gameProcess;

                    if (dalamudConsoleOutput.Handle == 0)
                    {
                        Console.WriteLine($"Dalamud returned NULL process handle, attempting to recover by creating a new one from pid {dalamudConsoleOutput.Pid}...");
                        gameProcess = Process.GetProcessById(dalamudConsoleOutput.Pid);
                    }
                    else
                    {
                        gameProcess = new ExistingProcess((IntPtr)dalamudConsoleOutput.Handle);
                    }

                    try
                    {
                        Console.WriteLine($"Got game process handle {gameProcess.Handle} with pid {gameProcess.Id}");
                    }
                    catch (InvalidOperationException ex)
                    {
                        Console.WriteLine(ex.Message, $"Dalamud returned invalid process handle {gameProcess.Handle}, attempting to recover by creating a new one from pid {dalamudConsoleOutput.Pid}...");
                        gameProcess = Process.GetProcessById(dalamudConsoleOutput.Pid);
                        Console.WriteLine($"Recovered with process handle {gameProcess.Handle}");
                    }

                    if (gameProcess.Id != dalamudConsoleOutput.Pid)
                        Console.WriteLine($"Internal Process ID {gameProcess.Id} does not match Dalamud provided one {dalamudConsoleOutput.Pid}");

                    return gameProcess;
                }
                catch (JsonReaderException ex)
                {
                    Console.WriteLine(ex.Message, $"Couldn't parse Dalamud output: {output}");
                    return null;
                }
            }
            catch (Exception ex)
            {
                throw new DalamudRunnerException("Error trying to start Dalamud.", ex);
            }
        }

        /// <summary>
        /// DUPLICATE_* values for DuplicateHandle's dwDesiredAccess.
        /// </summary>
        [Flags]
        private enum DuplicateOptions : uint
        {
            /// <summary>
            /// Closes the source handle. This occurs regardless of any error status returned.
            /// </summary>
            CloseSource = 0x00000001,

            /// <summary>
            /// Ignores the dwDesiredAccess parameter. The duplicate handle has the same access as the source handle.
            /// </summary>
            SameAccess = 0x00000002,
        }

        /// <summary>
        /// Duplicates an object handle.
        /// </summary>
        /// <param name="hSourceProcessHandle">
        /// A handle to the process with the handle to be duplicated.
        ///
        /// The handle must have the PROCESS_DUP_HANDLE access right.
        /// </param>
        /// <param name="hSourceHandle">
        /// The handle to be duplicated. This is an open object handle that is valid in the context of the source process.
        /// For a list of objects whose handles can be duplicated, see the following Remarks section.
        /// </param>
        /// <param name="hTargetProcessHandle">
        /// A handle to the process that is to receive the duplicated handle.
        ///
        /// The handle must have the PROCESS_DUP_HANDLE access right.
        /// </param>
        /// <param name="lpTargetHandle">
        /// A pointer to a variable that receives the duplicate handle. This handle value is valid in the context of the target process.
        ///
        /// If hSourceHandle is a pseudo handle returned by GetCurrentProcess or GetCurrentThread, DuplicateHandle converts it to a real handle to a process or thread, respectively.
        ///
        /// If lpTargetHandle is NULL, the function duplicates the handle, but does not return the duplicate handle value to the caller. This behavior exists only for backward compatibility with previous versions of this function. You should not use this feature, as you will lose system resources until the target process terminates.
        ///
        /// This parameter is ignored if hTargetProcessHandle is NULL.
        /// </param>
        /// <param name="dwDesiredAccess">
        /// The access requested for the new handle. For the flags that can be specified for each object type, see the following Remarks section.
        ///
        /// This parameter is ignored if the dwOptions parameter specifies the DUPLICATE_SAME_ACCESS flag. Otherwise, the flags that can be specified depend on the type of object whose handle is to be duplicated.
        ///
        /// This parameter is ignored if hTargetProcessHandle is NULL.
        /// </param>
        /// <param name="bInheritHandle">
        /// A variable that indicates whether the handle is inheritable. If TRUE, the duplicate handle can be inherited by new processes created by the target process. If FALSE, the new handle cannot be inherited.
        ///
        /// This parameter is ignored if hTargetProcessHandle is NULL.
        /// </param>
        /// <param name="dwOptions">
        /// Optional actions.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is nonzero.
        ///
        /// If the function fails, the return value is zero. To get extended error information, call GetLastError.
        /// </returns>
        /// <remarks>
        /// See https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-duplicatehandle.
        /// </remarks>
        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DuplicateHandle(
            IntPtr hSourceProcessHandle,
            IntPtr hSourceHandle,
            IntPtr hTargetProcessHandle,
            out IntPtr lpTargetHandle,
            uint dwDesiredAccess,
            [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle,
            DuplicateOptions dwOptions);

        private static Process GetInheritableCurrentProcessHandle()
        {
            if (!DuplicateHandle(Process.GetCurrentProcess().Handle, Process.GetCurrentProcess().Handle, Process.GetCurrentProcess().Handle, out var inheritableCurrentProcessHandle, 0, true, DuplicateOptions.SameAccess))
            {
                Console.WriteLine("Failed to call DuplicateHandle: Win32 error code {0}", Marshal.GetLastWin32Error());
                return null;
            }

            return new ExistingProcess(inheritableCurrentProcessHandle);
        }
    }
    public class ExistingProcess : Process
    {
        public ExistingProcess(IntPtr handle)
        {
            SetHandle(handle);
        }

        private void SetHandle(IntPtr handle)
        {
            var baseType = GetType().BaseType;
            if (baseType == null)
                return;

            var setProcessHandleMethod = baseType.GetMethod("SetProcessHandle",
                BindingFlags.NonPublic | BindingFlags.Instance);
            setProcessHandleMethod?.Invoke(this, new object[] { new SafeProcessHandle(handle, true) });
        }
    }
    public class WindowsDalamudCompatibilityCheck : IDalamudCompatibilityCheck
    {
        public void EnsureCompatibility()
        {
            if (!CheckVcRedists())
                throw new IDalamudCompatibilityCheck.NoRedistsException();

            EnsureArchitecture();
        }

        private static void EnsureArchitecture()
        {
            var arch = RuntimeInformation.ProcessArchitecture;

            switch (arch)
            {
                case Architecture.X86:
                    throw new IDalamudCompatibilityCheck.ArchitectureNotSupportedException("Dalamud is not supported on x86 architecture.");

                case Architecture.X64:
                    break;

                case Architecture.Arm:
                    throw new IDalamudCompatibilityCheck.ArchitectureNotSupportedException("Dalamud is not supported on ARM32.");

                case Architecture.Arm64:
                    throw new IDalamudCompatibilityCheck.ArchitectureNotSupportedException("x64 emulation was not detected. Please make sure to run XIVLauncher with x64 emulation.");
            }
        }

        [DllImport("kernel32", SetLastError = true)]
        private static extern IntPtr LoadLibrary(string lpFileName);

        private static bool CheckLibrary(string fileName)
        {
            if (LoadLibrary(fileName) != IntPtr.Zero)
            {
                Console.WriteLine("Found " + fileName);
                return true;
            }
            else
            {
                Console.WriteLine("Could not find " + fileName);
            }
            return false;
        }

        private static bool CheckVcRedists()
        {
            // snipped from https://stackoverflow.com/questions/12206314/detect-if-visual-c-redistributable-for-visual-studio-2012-is-installed
            // and https://github.com/bitbeans/RedistributableChecker

            var vc2022Paths = new List<string>
        {
            @"SOFTWARE\Microsoft\DevDiv\VC\Servicing\14.0\RuntimeMinimum",
            @"SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\X64",
            @"SOFTWARE\Classes\Installer\Dependencies\Microsoft.VS.VC_RuntimeMinimumVSU_amd64,v14",
            @"SOFTWARE\Classes\Installer\Dependencies\VC,redist.x64,amd64,14.31,bundle",
            @"SOFTWARE\Classes\Installer\Dependencies\VC,redist.x64,amd64,14.30,bundle",
            @"SOFTWARE\Classes\Installer\Dependencies\VC,redist.x64,amd64,14.29,bundle",
            @"SOFTWARE\Classes\Installer\Dependencies\VC,redist.x64,amd64,14.28,bundle",
            // technically, this was introduced in VCrun2017 with 14.16
            // but we shouldn't go that far
            // here's a legacy vcrun2017 check
            @"Installer\Dependencies\,,amd64,14.0,bundle",
            // here's one for vcrun2015
            @"SOFTWARE\Classes\Installer\Dependencies\{d992c12e-cab2-426f-bde3-fb8c53950b0d}"
        };

            var dllPaths = new List<string>
        {
            "ucrtbase_clr0400",
            "vcruntime140_clr0400",
            "vcruntime140"
        };

            var passedRegistry = false;
            var passedDllChecks = true;

            foreach (var path in vc2022Paths)
            {
                Console.WriteLine("Checking Registry key: " + path);
                var vcregcheck = Registry.LocalMachine.OpenSubKey(path, false);
                if (vcregcheck == null) continue;

                var vcVersioncheck = vcregcheck.GetValue("Version") ?? "";

                if (((string)vcVersioncheck).StartsWith("14", StringComparison.Ordinal))
                {
                    passedRegistry = true;
                    Console.WriteLine("Passed Registry Check with: " + path);
                    break;
                }
            }

            foreach (var path in dllPaths)
            {
                Console.WriteLine("Checking for DLL: " + path);
                passedDllChecks = passedDllChecks && CheckLibrary(path);
            }

            // Display our findings
            if (!passedRegistry)
            {
                Console.WriteLine("Failed all registry checks to find any Visual C++ 2015-2022 Runtimes.");
            }

            if (!passedDllChecks)
            {
                Console.WriteLine("Missing DLL files required by Dalamud.");
            }

            return (passedRegistry && passedDllChecks);
        }
    }
    public class WindowsRestartManager : IDisposable
    {
        public delegate void RmWriteStatusCallback(uint percentageCompleted);

        private const int RM_SESSION_KEY_LEN = 16; // sizeof GUID
        private const int CCH_RM_SESSION_KEY = RM_SESSION_KEY_LEN * 2;
        private const int CCH_RM_MAX_APP_NAME = 255;
        private const int CCH_RM_MAX_SVC_NAME = 63;
        private const int RM_INVALID_TS_SESSION = -1;
        private const int RM_INVALID_PROCESS = -1;
        private const int ERROR_MORE_DATA = 234;

        [StructLayout(LayoutKind.Sequential)]
        public struct RmUniqueProcess
        {
            public int dwProcessId; // PID
            public FILETIME ProcessStartTime; // Process creation time
        }

        public enum RmAppType
        {
            /// <summary>
            /// Application type cannot be classified in known categories
            /// </summary>
            RmUnknownApp = 0,

            /// <summary>
            /// Application is a windows application that displays a top-level window
            /// </summary>
            RmMainWindow = 1,

            /// <summary>
            /// Application is a windows app but does not display a top-level window
            /// </summary>
            RmOtherWindow = 2,

            /// <summary>
            /// Application is an NT service
            /// </summary>
            RmService = 3,

            /// <summary>
            /// Application is Explorer
            /// </summary>
            RmExplorer = 4,

            /// <summary>
            /// Application is Console application
            /// </summary>
            RmConsole = 5,

            /// <summary>
            /// Application is critical system process where a reboot is required to restart
            /// </summary>
            RmCritical = 1000,
        }

        [Flags]
        public enum RmRebootReason
        {
            /// <summary>
            /// A system restart is not required.
            /// </summary>
            RmRebootReasonNone = 0x0,

            /// <summary>
            /// The current user does not have sufficient privileges to shut down one or more processes.
            /// </summary>
            RmRebootReasonPermissionDenied = 0x1,

            /// <summary>
            /// One or more processes are running in another Terminal Services session.
            /// </summary>
            RmRebootReasonSessionMismatch = 0x2,

            /// <summary>
            /// A system restart is needed because one or more processes to be shut down are critical processes.
            /// </summary>
            RmRebootReasonCriticalProcess = 0x4,

            /// <summary>
            /// A system restart is needed because one or more services to be shut down are critical services.
            /// </summary>
            RmRebootReasonCriticalService = 0x8,

            /// <summary>
            /// A system restart is needed because the current process must be shut down.
            /// </summary>
            RmRebootReasonDetectedSelf = 0x10,
        }

        [Flags]
        private enum RmShutdownType
        {
            RmForceShutdown = 0x1, // Force app shutdown
            RmShutdownOnlyRegistered = 0x10 // Only shutdown apps if all apps registered for restart
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct RmProcessInfo
        {
            public RmUniqueProcess UniqueProcess;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = CCH_RM_MAX_APP_NAME + 1)]
            public string AppName;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = CCH_RM_MAX_SVC_NAME + 1)]
            public string ServiceShortName;

            public RmAppType ApplicationType;
            public int AppStatus;
            public int TSSessionId;

            [MarshalAs(UnmanagedType.Bool)]
            public bool bRestartable;

            public Process Process
            {
                get
                {
                    try
                    {
                        Process process = Process.GetProcessById(UniqueProcess.dwProcessId);
                        long fileTime = process.StartTime.ToFileTime();

                        if ((uint)UniqueProcess.ProcessStartTime.dwLowDateTime != (uint)(fileTime & uint.MaxValue))
                            return null;

                        if ((uint)UniqueProcess.ProcessStartTime.dwHighDateTime != (uint)(fileTime >> 32))
                            return null;

                        return process;
                    }
                    catch (Exception)
                    {
                        return null;
                    }
                }
            }
        }

        [DllImport("rstrtmgr", CharSet = CharSet.Unicode)]
        private static extern int RmStartSession(out int dwSessionHandle, int sessionFlags, StringBuilder strSessionKey);

        [DllImport("rstrtmgr")]
        private static extern int RmEndSession(int dwSessionHandle);

        [DllImport("rstrtmgr")]
        private static extern int RmShutdown(int dwSessionHandle, RmShutdownType lAtionFlags, RmWriteStatusCallback fnStatus);

        [DllImport("rstrtmgr")]
        private static extern int RmRestart(int dwSessionHandle, int dwRestartFlags, RmWriteStatusCallback fnStatus);

        [DllImport("rstrtmgr")]
        private static extern int RmGetList(int dwSessionHandle, out int nProcInfoNeeded, ref int nProcInfo, [In, Out] RmProcessInfo[] rgAffectedApps, out RmRebootReason dwRebootReasons);

        [DllImport("rstrtmgr", CharSet = CharSet.Unicode)]
        private static extern int RmRegisterResources(int dwSessionHandle,
                                                      int nFiles, string[] rgsFileNames,
                                                      int nApplications, RmUniqueProcess[] rgApplications,
                                                      int nServices, string[] rgsServiceNames);

        private readonly int sessionHandle;
        private readonly string sessionKey;

        public WindowsRestartManager()
        {
            var sessKey = new StringBuilder(CCH_RM_SESSION_KEY + 1);
            ThrowOnFailure(RmStartSession(out sessionHandle, 0, sessKey));
            sessionKey = sessKey.ToString();
        }

        public void Register(IEnumerable<FileInfo> files = null, IEnumerable<Process> processes = null, IEnumerable<string> serviceNames = null)
        {
            string[] filesArray = files?.Select(f => f.FullName).ToArray() ?? Array.Empty<string>();
            RmUniqueProcess[] processesArray = processes?.Select(f => new RmUniqueProcess
            {
                dwProcessId = f.Id,
                ProcessStartTime = new FILETIME
                {
                    dwLowDateTime = (int)(f.StartTime.ToFileTime() & uint.MaxValue),
                    dwHighDateTime = (int)(f.StartTime.ToFileTime() >> 32),
                }
            }).ToArray() ?? Array.Empty<RmUniqueProcess>();
            string[] servicesArray = serviceNames?.ToArray() ?? Array.Empty<string>();
            ThrowOnFailure(RmRegisterResources(sessionHandle,
                filesArray.Length, filesArray,
                processesArray.Length, processesArray,
                servicesArray.Length, servicesArray));
        }

        public void Shutdown(bool forceShutdown = true, bool shutdownOnlyRegistered = false, RmWriteStatusCallback cb = null)
        {
            ThrowOnFailure(RmShutdown(sessionHandle, (forceShutdown ? RmShutdownType.RmForceShutdown : 0) | (shutdownOnlyRegistered ? RmShutdownType.RmShutdownOnlyRegistered : 0), cb));
        }

        public void Restart(RmWriteStatusCallback cb = null)
        {
            ThrowOnFailure(RmRestart(sessionHandle, 0, cb));
        }

        public List<RmProcessInfo> GetInterferingProcesses(out RmRebootReason rebootReason)
        {
            var count = 0;
            var infos = new RmProcessInfo[count];
            var err = 0;

            for (var i = 0; i < 16; i++)
            {
                err = RmGetList(sessionHandle, out int needed, ref count, infos, out rebootReason);

                switch (err)
                {
                    case 0:
                        return infos.Take(count).ToList();

                    case ERROR_MORE_DATA:
                        infos = new RmProcessInfo[count = needed];
                        break;

                    default:
                        ThrowOnFailure(err);
                        break;
                }
            }

            ThrowOnFailure(err);

            // should not reach
            throw new InvalidOperationException();
        }

        private void ReleaseUnmanagedResources()
        {
            ThrowOnFailure(RmEndSession(sessionHandle));
        }

        public void Dispose()
        {
            ReleaseUnmanagedResources();
            GC.SuppressFinalize(this);
        }

        ~WindowsRestartManager()
        {
            ReleaseUnmanagedResources();
        }

        private void ThrowOnFailure(int err)
        {
            if (err != 0)
                throw new Win32Exception(err);
        }
    }
    public class WindowsSteam : ISteam
    {
        public WindowsSteam()
        {
            SteamUtils.OnGamepadTextInputDismissed += b => OnGamepadTextInputDismissed?.Invoke(b);
        }

        public void Initialize(uint appId)
        {
            // workaround because SetEnvironmentVariable doesn't actually touch the process environment on unix
            if (Environment.OSVersion.Platform == PlatformID.Unix)
            {
                [System.Runtime.InteropServices.DllImport("c")]
                static extern int setenv(string name, string value, int overwrite);

                setenv("SteamAppId", appId.ToString(), 1);
            }

            SteamClient.Init(appId);
        }

        public bool IsValid => SteamClient.IsValid;

        public bool BLoggedOn => SteamClient.IsLoggedOn;

        public bool BOverlayNeedsPresent => SteamUtils.DoesOverlayNeedPresent;

        public void Shutdown()
        {
            SteamClient.Shutdown();
        }

        public async Task<byte[]?> GetAuthSessionTicketAsync()
        {
            var ticket = await SteamUser.GetAuthSessionTicketAsync().ConfigureAwait(true);
            return ticket?.Data;
        }

        public bool IsAppInstalled(uint appId)
        {
            return SteamApps.IsAppInstalled(appId);
        }

        public string GetAppInstallDir(uint appId)
        {
            return SteamApps.AppInstallDir(appId);
        }

        public bool ShowGamepadTextInput(bool password, bool multiline, string description, int maxChars, string existingText = "")
        {
            return SteamUtils.ShowGamepadTextInput(password ? GamepadTextInputMode.Password : GamepadTextInputMode.Normal, multiline ? GamepadTextInputLineMode.MultipleLines : GamepadTextInputLineMode.SingleLine, description, maxChars, existingText);
        }

        public string GetEnteredGamepadText()
        {
            return SteamUtils.GetEnteredGamepadText();
        }

        public bool ShowFloatingGamepadTextInput(ISteam.EFloatingGamepadTextInputMode mode, int x, int y, int width, int height)
        {
            // Facepunch.Steamworks doesn't have this...
            return false;
        }

        public bool IsRunningOnSteamDeck() => false;

        public uint GetServerRealTime() => (uint)((DateTimeOffset)SteamUtils.SteamServerTime).ToUnixTimeSeconds();

        public void ActivateGameOverlayToWebPage(string url, bool modal = false)
        {
            SteamFriends.OpenWebOverlay(url, modal);
        }

        public event Action<bool> OnGamepadTextInputDismissed;
    }
}